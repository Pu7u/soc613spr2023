---
title: "Week 9: Introduction to Exponential Random Graph Models"
author: "Ryan Light with significant collaboration with jimi adams"
date: "5/26/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction to ERGMs

Let's dig into exponential random graph models in R.

Recall Robins and Lusher (2013:13): "Exponential random graph models (ERGMs) are statistical models for network structure permitting inferences about how network ties are patterned. Put it another way, ERGMs are tie-based models for understanding how and why social network ties arise." 

ERGMs are the most popular ways of thinking about the factors that led to an observed network coming about for several reasons: 1. computationally OK 2. allow for theory-testing (often highlight competing theories) 3. easy to implement in R with good support materials.

For example, you may wonder what factors lead to romantic encounters between fictional medical professionals. What is the effect of monogamy in this network (or at least the effect of someone who is only willing to date one colleague)? What is the effect of racial homophily?

We will begin with a network based on Grey's Anatomy Hook Ups. This case was developed by Gary Weissman and Benjamin Lind years ago (http://badhessian.org/2012/09/lessons-on-exponential-random-graph-modeling-from-greys-anatomy-hook-ups/), so the network is dated. 

In addition to the code developed by Lind, I also follow along with Luke (2015), Goordeau et al. (2008), among others.

Luke, D. A. (2015). A user's guide to network analysis in R. London: Springer.

Goodreau, S. M., Handcock, M. S., Hunter, D. R., Butts, C. T., & Morris, M. (2008). A statnet tutorial. Journal of statistical software, 24(9), 1.

First let's load the data and explore in statnet.

```{r, echo=T, message=FALSE}

library(statnet)

load("ergm_data.Rdata")

```

The Grey's data should be in the environment now.

We can make a vertex attribute in statnet:

Let's make an age variable

```{r, echo=T, message=FALSE}

set.vertex.attribute(greys, "age", 2013-get.vertex.attribute(greys, "birthyear"))

```


Let's plot the network in statnet for an overview

```{r, echo=T, message=FALSE}

la <- plot(greys)		#fix plot coordinates, so they don't jump around if we replot later

#Component size distribution

table(component.dist(greys)$csize)

#Plot with attributes

plot.network(greys,  vertex.col=get.vertex.attribute(greys, "nrace"), 		# Numeric conversion of race variable
     label=get.vertex.attribute(greys, "name"), label.cex=.75, 		# Names
     vertex.sides=(50*(get.vertex.attribute(greys, "sex")=="F")+4), 	# circles=women, squares=men
     vertex.cex=.05*(get.vertex.attribute(greys, "age")))	# size proportional to age

```

Let's begin to observe differences in gender by looking at degree distributions. 

degree(g) 

As the network is undirected, we use degree(g)/2.



```{r, echo=T, message=FALSE}

degree(greys)

gry.degreedist <- table(degree(greys)/2)

gry.degreedist 

#Compare degree distribution by sex

summary(greys ~ degree(0:8, "sex"))

```

We can count triangles.

```{r, echo=T, message=FALSE}


#Triangle count

summary(greys~triangle)

summary(greys~cycle(4))

```

We can look at the mixing matrices by sex and race.

```{r, echo=T, message=FALSE}

#Mixing matrix by Sex

mixingmatrix(greys, "sex")

#Mixing matrix by Race

mixingmatrix(greys, "race")

```


## Fitting an ERGM: Null Model

Now we can start fitting an ERGM. Let's start with the null model or the equivalent of running a regression with just its intercept. The null model for ergms is called  Bernoulli model where the is an equal probability for all edges in a network. We are basically adding the number of edges in addition to the number of nodes as a factor in the model.

There are numerous network terms that we use in these equations from statnet. The term for this baseline model is edges.

So the function will look like this:

ergm(g ~ edges)

```{r, echo=T, message=TRUE}

model1 <- ergm(greys ~ edges)

summary(model1)

```

The coefficient is difficult to make sense of, so we can use the plogis function to exponentiate the coefficient and provide a probability of there being a tie. We can see that this is exactly the same as network density.


```{r, echo=T, message=TRUE}

plogis(coef(model1))

network.density(greys)

```

There is a .048 probability of their being a tie between two nodes in this graph which is the same as saying that the graph has a density of .048.

## Fitting an ERGM: Adding Exogenous Factors

ERGM fits a logistic regression in this case as dyads are independent of one another.

But we know this network is nonrandom and other factors likely contribute to network structure.

First, let's add node attributes.

In statnet we use nodefactor("attribute") for categorical and nodecov("attribute") for ratio/interval variables. 

We may wonder if men or women are more likely to form hookup ties in the Grey's Anatomy network.

```{r, echo=T, message=TRUE}

model2 <- ergm(greys ~ edges + nodefactor("sex"))

summary(model2)

```

The variable is not significant and therefore sex doesn't seem to matter for this network by itself.

We can evaluate the maximum likelihood (higher is better) and AIC (lower is better).

```{r, echo=T, message=TRUE}

model1$mle.lik[1]
model2$mle.lik[1]

model1$glm$aic
model2$glm$aic
```

And we can see that the performance is actually worse for model 2.

Now, let's look first at assortative mixing

Sex homophily - use the nodematch term: nodematch("sex")

```{r, echo=T, message=TRUE}

model3 <- ergm(greys ~ edges + nodematch("sex"))

summary(model3)

exp(coef(model3))

```

This is a pretty heteronormative show, so we would expect that same-sex relationships would be rare. 

This is indeed the case as the matching on sex reduces the likelihood of having a tie by about 96%.


```{r, echo=T, message=TRUE}

model1$mle.lik[1]
model3$mle.lik[1]

model1$glm$aic
model3$glm$aic
```

We are still modeling logistic regressions as network configuration terms are not included (e.g. our model of tie formation does not depend on other ties).

Let's look at race nodematch("race") as well to see two main competing exogenous factors.

```{r, echo=T, message=FALSE}

model3a <- ergm(greys ~ edges + nodematch("race"))

summary(model3a)

exp(coef(model3a))

```

Homophily by race doubles the likelihood of edge formation in this graph.

Let's look at both.

```{r, echo=T, message=FALSE}
model3c <- ergm(greys ~ edges + nodematch("sex") + nodematch("race"))

summary(model3c)

model3c$mle.lik[1]

```

Note that when including nodematch terms one also would typically include nodefactor as well ("main effects" vs."interaction effects")


## Endogenous Terms

Let's add network configurations to this model. A list of ergm terms is here:
https://cran.r-project.org/web/packages/ergm/vignettes/ergm-term-crossRef.html

The first thing that we might be interested in is a monogamy effect. We can find that by evaluating the effect of having a degree of 1 or the network term degree(1).

```{r, echo=T, message=T, error=T}

model4 <- ergm(greys ~ edges + degree(1))

```

Model fails to converge. So we try again. As our model includes the match terms, let's keep them. Nested models here aren't as interpretable as in canonical regression due to the interdependence of model terms.

```{r, echo=T}

model4a <- ergm(greys~edges + degree(1) + nodematch("sex") + nodematch("race"))

summary(model4a)

exp(coef(model4a))

```

Prior research show that four-cycles are rare in most relationship networks.

Unfortunately, the model including the 4-cycle doesn't work. So we can try some other network terms. The triangle and the other clustering variables don't work very well. This is likely again due to the lack of closure between triads due to heteronormativity.

We can evaluate the other side of this equation by turning to 2-stars (a node sends to two other nodes with no connection between them (e.g. an intransitive triad)).



```{r, echo=T}

model4b <- ergm(greys ~ edges + degree(1) + kstar(2) + nodematch("sex") + nodematch("race"), control=control.ergm(seed=50, SAN.maxit = 6))

summary(model4b)

model4a$mle.lik[1]
model4b$mle.lik[1]

```
We have been concerned with model improvement, but should actually have been also considering model fit. We specifically want to know how well properties of the simulated model fit with the observed network. This gives us confidence in the model itself. The technique for doing this takes advantage of a unique property of our models. We modeled local properties of networks with the theory that local properties aggregate into the network as a whole. So, no whole network statistics were used to model our graph. We can use network-wide statistics to compare the simulated and observed networks.

We would expect that the observed network statistics would be in the confidence intervals of the simulated networks.

The gof function gets us the goodness-of-fit statistics in statnet

gof(model)

and we can save and plot:

gof.thing <- gof(model)

plot(gof.thing)

```{r, echo=T}

gof4b <- gof(model4b)

plot(gof4b)


```

And we can see that the observed statistics are generally well within the intervals. The model fits the data.

We should always also check for degeneracy. We want to make sure that the simulation process worked. We have some indication that it did as the models actually spit something out, but we should check and make sure.

The estimates should be normally distributed and centered on 0. The mcm.diagnostics function will give us the information we need especially a series of graphs of the covariates. We will see the normal distribution (or not) on the left side of the graphs. On the right side we will see a plot of the "noise" around 0 and it should look like almost like a solid blue horizontal line with jagged edges. If the peak of the distribution (right side) is very different than 0 or if the plot of a ratio variable has multiple peaks (right side) or if the left side has a slope or if the blue ban is very narrow, then you likely have degeneracy problems. 

```{r, echo=T}


mcmc.diagnostics(model4b)

```

These are distributed around 0 and so we can be confident that our models aren't degenerate. Note that the nodematch.sex is a bumpy because of it consists of a few categories. 

```{r, echo=T}

exp(coef(model4b))

plogis(coef(model4b))

```
Let's return to the covariates. It is common to talk about results of an ergm by focusing on the statistical significance and magnitude of the estimates (b). For example, we can see that there is a large negative effect of gender homophily suggesting that different-sex partnerships are commnon in this network. Workplace dramas, like Grey's Anatomy, feed of the overlapping romantic interests of main characters. However, it makes sense that drama on the margins is less useful. Keeping track of tertiary conflicts becomes cumbersome. We see that the narrative follows this logic as having a degree of 1 is positive and relatively strong. Racial homophily is not as strong, but is strong consistent with racialized presentations of heternormative sexuality on tv. Interestingly, power effects - kind of reverse clustering - are not significant. Main characters are not shuffling through one-degree partners. Again, this is consistent with how tv storylines require overlaps in the central characters romantic networks.

We can also discuss either odds ratios or probablities for tie formation of our significant variables of interest (here, monogamy, racial homophily, and gender homophily).

We can see that monogamy is an important factor in this network. There is a .87 probabilty that an edge connects a node with a degree of 1. The graph is heternormative as the gender factor is very small. And racial homophily is an important positive factor with a probability of .67. 

A few notes on extensions to come in Week 10. 

```{r, echo=F}

#library(knitr)
#purl("wk9_ergm_wksp.Rmd")

```
